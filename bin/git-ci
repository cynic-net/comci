#!/usr/bin/env bash
set -e

# Usage/Git Setup
# ---------------

USAGE='[help|list|run|show]'
LONG_USAGE='git ci help
    print this long help message

git ci (l|list)
    list available tests

git ci (r|run) <revision> <test-name>
    run specified test against revision

git ci (s|show) <revision> <test-name>*
    show results of tests on specified revision'

OPTIONS_SPEC=

. "$(git --exec-path)/git-sh-setup"

# Utilities
# ---------

die()  { echo "fatal: $@" 1>&2 ; exit 1 ; }
warn() { echo "warning: $@" 1>&2 ; }

config_branch=ci/config
results_ref=refs/ci/results/master

# Configuration Parsing
# ---------------------

check_config_exists() {
    git show-ref --quiet --verify "refs/heads/$config_branch" \
        || die "Couldn't find branch $config_branch"
    git cat-file -e "$config_branch:config" 2>/dev/null \
        || die "config file doesn't exist on branch $config_branch"
}

cat_config() { git cat-file blob "$config_branch:config" ; }
ci_config()  { cat_config | git config --file=- "$@"     ; }

set_test_names() {
    check_config_exists
    test_names=()
    while read test_name; do
        local test_name_no_prefix="${test_name#test.}"
        local test_name_untested="${test_name_no_prefix%.command}"
        if echo "$test_name_untested" | grep ' ' &>/dev/null; then
            warn "Invalid test name: '$test_name_untested'"
        else
            test_names+=("$test_name_untested")
        fi
    done < <( ci_config --name-only --get-regexp 'test\..*\.command' )
}

get_test_command() {
    check_config_exists
    local test_name="$1"; shift
    ci_config --get "test.$test_name.command"
}

# Initialize git ci
# -----------------

ci_init() {
    ! git show-ref --quiet --verify "$results_ref" \
        || die "git ci already init-ed"

    local empty_tree_sha="$(git hash-object -w -t tree /dev/null)"
    local init_commit_sha="$(git commit-tree -m 'Initilizing git ci' "$empty_tree_sha")"

    git update-ref -m 'git-ci init' "$results_ref" "$init_commit_sha"
}

# List Tests
# ----------

list_tests() {
    set_test_names
    for test in ${test_names[@]}; do echo $test; done
}

check_tests_exist() {
    for test_name in "$@"; do
        get_test_command "$test_name" &>/dev/null \
            || die "Bad test name: $test_name"
    done
}

# Show Tests
# ----------

format_result() {
    local commitish="$1"; shift
    local test_name="$1"; shift
    local treeish=$(git rev-parse "$commitish^{tree}")
    local status_name='exit-code'

    echo
    echo "    ### $results_ref:$treeish/$test_name/$status_name"
    echo
    ### Grrrr, shouldn't -e suppress output for us?
    if git cat-file -e "$results_ref:$treeish/$test_name/$status_name" &>/dev/null; then
        echo "    $(git cat-file blob "$results_ref:$treeish/$test_name/$status_name")"
    else
        echo "    No results."
    fi
}

show_results() {
    local commitish="$1"; shift
    git cat-file -e "${commitish}^{commit}" \
        || die "Not a commit: ${commitish}"

    local format="%w(80,0,8)%h - %s"

    check_tests_exist "$@"

    for test_name in "$@"; do
        git --no-pager log -1 "$commitish" --pretty="format:$format"
        echo
        format_result $commitish "$test_name"
        echo
    done
}

# Recording Results
# -----------------

export_temp_index() {
    export GIT_INDEX_FILE="$(mktemp --tmpdir git-ci.tmp-index.XXXXXXXXX)"
    git-read-tree "$results_ref"
}

add_to_index() { # args: tree entry name, path to data
    local entry_data_path="$1" ; shift
    local entry_file_path="$1" ; shift
    local entry_sha="$(git hash-object -t blob -w "$entry_data_path")"
    echo -e "100644 blob $entry_sha\t$entry_file_path" \
        | git update-index --index-info
}

commit_index() {
    local tree_sha="$(git write-tree)"
    local commit_sha="$(git commit-tree "$tree_sha" -p "$results_ref" "$@")"
    git update-ref "$results_ref" "$commit_sha"
}

# Run Tests
# ---------

run_test() {
    local commitish="$1" ; shift
    local test_name="$1" ; shift

    local treeish="$(git rev-parse "$commitish^{tree}")"
    local test_command="$(get_test_command "$test_name")"

    local tmp_dir="$(mktemp --tmpdir --directory git-ci.XXXXXXXXXX)"
    local tmp_worktree="$tmp_dir/worktree"
    mkdir -p "$tmp_worktree"

    local status=0
    trap "rm -rf '$tmp_dir'" 0
    (   set -e
        export GIT_WORK_TREE="$tmp_worktree"
        git read-tree "$commitish"
        git checkout-index --all
        cd "$tmp_worktree"
        sh -c "$test_command"
    ) || status="$?"

    (   export_temp_index
        add_to_index <(echo "$status") "$treeish/$test_name/exit-code"
        commit_index -m "git ci test results: $treeish/$test_name"
    )
    return "$status"
}

run_tests() {
    local revision="$1" && shift || die "'git ci run' requires a revision and a list of test-names"

    git cat-file -e "$revision" 2>/dev/null \
        || die "Bad revision: $revision"

    check_tests_exist "$@"
    local status_acc='0'
    for test_name in "$@"; do
        git --no-pager log -1 "$revision" --oneline
        echo
        echo "== running: $test_name"
        echo

        local status='0'
        run_test "$revision" "$test_name" || status="$?"
        echo
        if [[ "$status" == '0' ]]; then
            echo "== passed: $test_name on $revision"
        else
            echo "== failed: $test_name on $revision"
            status_acc='1'
        fi
        echo
        echo
    done
    exit "$status_acc"
}

# Main
# ----

[[ "$1" == "--define-functions-only" ]] && return
[[ "$#" == '0' ]] && usage

cmd="$1" && shift
case "$cmd" in
    help)     git ci -h ;;
    i|init)   ci_init      "$@" ;;
    l|list)   list_tests   "$@" ;;
    c|config) ci_config    "$@" ;;
    r|run)    run_tests    "$@" ;;
    s|show)   show_results "$@" ;;
    *)        usage ;;
esac
