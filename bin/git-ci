#!/usr/bin/env bash
set -e

# Usage/Git Setup
# ---------------

USAGE='[help|list|run|show]'
LONG_USAGE='git ci help
    print this long help message

git ci (l|list)
    list available tests

git ci (r|run) <revision> <test-name>
    run specified test against revision

git ci (s|show) <revision> <test-name>*
    show results of tests on specified revision'

OPTIONS_SPEC=

. "$(git --exec-path)/git-sh-setup"

# Utilities
# ---------

die()  { echo "==   fatal: $@"; exit 1 ; }
warn() { echo "== warning: $@"; }

config_branch=ci/config

# Configuration Parsing
# ---------------------

check_config_exists() {
    git show-ref --quiet --verify "refs/heads/$config_branch" \
        || die "Couldn't find branch $config_branch"
    git cat-file -e "$config_branch:config" 2>/dev/null \
        || die "config file doesn't exist on branch $config_branch"
}

cat_config() {
    git cat-file blob "$config_branch:config"
}

set_test_names() {
    check_config_exists
    test_names=()
    while read test_name; do
        local test_name_no_prefix="${test_name#test.}"
        local test_name_untested="${test_name_no_prefix%.command}"
        if echo "$test_name_untested" | grep ' ' &>/dev/null; then
            warn "Invalid test name: '$test_name_untested'"
        else
            test_names+=("$test_name_untested")
        fi
    done < <( cat_config | git config --file=- --name-only --get-regexp 'test\..*\.command' )
}

get_test_command() {
    check_config_exists
    local test_name="$1"; shift
    cat_config | git config --file=- --get "test.$test_name.command"
}

# List Tests
# ----------

list_tests() {
    set_test_names
    for test in ${test_names[@]}; do echo $test; done
}

# Show Tests
# ----------

cat_test_results() {
    local test_branch="$1"; shift
    local commitish="$1"; shift
    local test_name="$1"; shift
    local status_name="$1"; shift

    git cat-file blob "refs/ci/results/$test_branch:$(git rev-parse "$commitish^{tree}")/$test_name/$status_name"
}

format_results() {
    local test_branch="$1"; shift
    local commitish="$1"; shift

    for test_name in "$@"; do
        local status_name='exit-code'
        echo
        echo "### refs/ci/results/$test_branch:$commitish/$test_name/$status_name"
        echo
        echo "$(cat_test_results $test_branch $commitish $test_name $status_name)"
    done
}

show_results() {
    local test_branch='master'
    local commitish="$1"; shift
    local format="format:%w(80,0,8)%C(bold green)%h$C(reset) - %C(dim blue)%s%C(reset)"
    git log -1 --pretty="$format
$(format_results $test_branch $commitish "$@")"
}

# Run Tests
# ---------

run_test() {
    revision="$1"; shift
    test_name="$1"; shift

    local tmp_dir="$(mktemp --directory tmp.git-ci.XXXXXXXXXX)"
    local status=0
    trap "rm -rf '$tmp_dir'" 0
    (   set -e
        export GIT_WORK_TREE="$tmp_dir"
        git read-tree "$revision"
        git checkout-index --all
        cd "$tmp_dir"
        sh -c "$test_command"
    )
}

run_tests() {
    local revision="$1"  && shift || die "'git ci run' requires a revision and a test-name"
    local test_name="$1" && shift || die "'git ci run' requires a revision and a test-name"
    [[ "$#" == '0' ]]             || die "Too many arguments"

    git cat-file -e "$revision" 2>/dev/null \
        || die "Bad revision: $revision"

    test_command="$(get_test_command "$test_name")" \
        || die "Bad test name: $test_name"

    status='0'
    run_test "$revision" "$test_command" || status="$?"
    case "$status" in
        0) echo "passed: $test_name on $revision"; return 0 ;;
        *) echo "failed: $test_name on $revision"; return 1 ;;
    esac
}

# Main
# ----

[[ "$1" == "--define-functions-only" ]] && return
[[ "$#" == '0' ]] && usage

cmd="$1" && shift
case "$cmd" in
    help)   git ci -h ;;
    l|list) list_tests   "$@" ;;
    r|run)  run_tests    "$@" ;;
    s|show) show_results "$@" ;;
    *)      usage ;;
esac
