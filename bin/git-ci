#!/usr/bin/env bash

set -e
# set -x

git_ci_command="$1" && shift
testset="$1"        && shift

ci_ref_prefix="refs/ci/$testset"

# Utilities
# ---------

notif() { echo "== git ci: $@" ; }
warn()  { notif "$@" >&2       ; }
fatal() { warn "$@" ; exit 1   ; }

clean_worktree_or_die() {
    git submodule update --init
    if ! git diff --quiet; then
        fatal "Must run with a clean worktree!!!"
    fi
}

# Configuration
# -------------

git_ci_config() {
    git config --file='.ci' "$@"
}

git_ci_tracked_files() {
    git_ci_config --get "test.$testset.trackedFiles"
}

# Storing Results
# ---------------

git_ci_add() {
    for file in $(git_ci_tracked_files); do
        [[ ! -f "$file" ]] || git add --force "$file"
        [[ ! -d "$file" ]] || git add --force "$file"
    done
}

git_ci_commit() {
    local source_commit source_tree ci_ref
    local tested_commit tested_tree tested_commit_parent

    source_commit="$(git rev-parse HEAD)"
    source_tree="$(git rev-parse "$source_commit^{tree}")"
    ci_ref="$ci_ref_prefix/$source_tree"

    tested_tree="$(git write-tree)"

    tested_commit_parent="$(git rev-parse --verify --quiet "$ci_ref")" \
        || tested_commit_parent="$(git commit-tree "$source_tree" -m "ci: init '$testset' on tree '$source_tree'")"
    tested_commit="$(git commit-tree -p "$tested_commit_parent" "$tested_tree" -m "ci: run '$testset' on commit '$source_commit'")"

    git update-ref "$ci_ref" "$tested_commit"
}

# Reading Results
# ---------------

git_ci_get() {
    local source_commit source_tree ci_ref
    { source_commit="$1" && shift ; } || source_commit='HEAD'
    source_tree="$(git rev-parse "$source_commit^{tree}")"
    ci_ref="$ci_ref_prefix/$source_tree"
    git rev-parse --verify --quiet "$ci_ref" &>/dev/null \
        || return
    echo "$ci_ref"
}

git_ci_last() {
    local source_commit curr_commit max_backtrack
    max_backtrack=50

    { source_commit="$1" && shift ; } || source_commit='HEAD'

    for i in $(seq 0 "$max_backtrack"); do
        curr_commit="$(git rev-parse --verify --quiet "$source_commit~$i")" \
            || break
        if git_ci_get "$curr_commit" &>/dev/null; then
            echo "$curr_commit"
            return 0
        fi
    done

    echo ''
    warn "No test results found between '$curr_commit..$source_commit'."
}

git_ci_list() {
    local source_commit

    { source_commit="$1" && shift ; } || source_commit='HEAD'

    source_commit="$(git_ci_last "$source_commit" 2>/dev/null)"
    while [[ "$source_commit" != '' ]]; do
        echo "$source_commit"
        source_commit="$(git_ci_last "$source_commit^" 2>/dev/null)"
    done
}

# Removing Results
# ----------------

git_ci_prune() {
    local source_commit source_tree ci_ref

    { source_commit="$1" && shift ; } || source_commit='HEAD'

    ci_ref="$(git_ci_get "$source_commit")" \
        || fatal "No test results for '$source_commit'."

    git update-ref -d "$ci_ref"
}

# Presenting Results
# ------------------

git_ci_diff() {
    local source_commit_one source_commit_two
    local tested_commit_one tested_commit_two

    source_commit_one="$1" && shift
    source_commit_two="$1" && shift

    tested_commit_two="$(git_ci_get "$source_commit_two")"
    if [[ "$source_commit_one" == '' ]]; then
        tested_commit_one="$source_commit_two"
    else
        tested_commit_one="$(git_ci_get "$source_commit_one")"
    fi

    git diff "$tested_commit_one" "$tested_commit_two" "$@"
}

git_ci_show() {
    local source_commit_one source_commit_two
    local tested_commit_one tested_commit_two

    { source_commit_one="$1" \
        && git rev-parse --verify --quiet "$source_commit_one" &>/dev/null \
        && shift
    } || source_commit_one='HEAD'
    source_commit_two="$(git_ci_last "$source_commit_one^")"

    git_ci_diff "$source_commit_two" "$source_commit_one" "$@"
}

# Generate a history for use with git-log or git-show. Outputs the commit id
# of the HEAD, but does not create a ref.

git_ci_gen_hist() {
    local source_commit source_ancestor source_message
    local tested_ancestor tested_ancestor_tree
    local generated_commit

    { source_commit="$1" \
        && git rev-parse --verify --quiet "$source_commit" &>/dev/null \
        && shift
    } || source_commit='HEAD'

    while read source_ancestor; do
        local parent_args=()
        [[ "$generated_commit" == "" ]] ||
            parent_args+=( '-p' "$generated_commit" )
        parent_args+=( '-p' "$source_ancestor" )

        tested_ancestor="$(git_ci_get "$source_ancestor")"
        tested_ancestor_tree="$(git rev-parse "$tested_ancestor^{tree}")"

        source_message="$(git log -n1 --format=%s "$source_ancestor")"
        generated_commit="$(git commit-tree "${parent_args[@]}" \
            "$tested_ancestor_tree" -m "ci: $testset: $source_message")"
    done < <(git_ci_list "$source_commit" | tac)
    echo "$generated_commit"
}

git_ci_log() {
    git log -m --first-parent "$@"
}

# Running Tests
# -------------

git_ci_cleanup() {
    git reset
    git checkout -- ./
    git clean -dfx
}

git_ci_test() {
    local test_command

    test_command="$(git_ci_config --get "test.$testset.command")"
    notif "running test '$test_command'"

    bash -c "$test_command"
}

git_ci_run() {
    local source_commit curhead exit_status

    source_commit="$1" && shift

    clean_worktree_or_die

    # TODO: record exit codes and report back correct exit code?
    # Perhaps with trailers in commit message? (git interpret-trailers)
    # Otherwise, `git bisect` with `git ci test` will be broken.
    ! git_ci_get "$source_commit" &>/dev/null \
        || { notif "Test results already exist for '$source_commit'."
             return 0
           }

    notif "Running tests on commit: '$source_commit'"

    curhead="$(git rev-parse --abbrev-ref HEAD)"
    trap "git checkout $curhead ; exit 1" INT TERM EXIT

    git checkout "$source_commit"

    exit_status='0'
    git_ci_cleanup
    git_ci_test     || exit_status="$?"
    git_ci_add
    git_ci_commit
    git_ci_cleanup

    git checkout "$curhead"

    return "$exit_status"
}

git_ci_run_linear() {
    local curhead exit_status
    local source_commit_one source_commit_two

    { source_commit_one="$1" && shift ; } || source_commit_one="HEAD"
    { source_commit_two="$1" && shift ; } || source_commit_two="^$source_commit_one^"

    clean_worktree_or_die

    curhead="$(git rev-parse --abbrev-ref HEAD)"
    trap "git checkout $curhead" INT TERM EXIT

    exit_status='0'
    for commit_id in $(git rev-list "$source_commit_one" "$source_commit_two"); do
        git checkout "$commit_id"
        git ci test "$testset" || exit_status="$?"
    done

    exit "$exit_status"
}

# Main
# ----

notif "$git_ci_command $testset $@"
case "$git_ci_command" in
    cleanup)    git_ci_cleanup         ;;
    test)       git_ci_test            ;;
    add)        git_ci_add             ;;
    commit)     git_ci_commit          ;;
    get)        git_ci_get        "$@" ;;
    run)        git_ci_run        "$@" ;;
    run-linear) git_ci_run_linear "$@" ;;
    diff)       git_ci_diff       "$@" ;;
    show)       git_ci_show       "$@" ;;
    last)       git_ci_last       "$@" ;;
    gen-hist)   git_ci_gen_hist   "$@" ;;
    list)       git_ci_list       "$@" ;;
    prune)      git_ci_prune      "$@" ;;
    log)        git_ci_log        "$@" ;;
    *)          expanded_alias=($(git config --get "alias.$git_ci_command")) \
                   || fatal "Unrecognized command: $git_ci_command"
                eval git ci "${expanded_alias[0]}" "$testset" "${expanded_alias[@]:1}" "$@"
                ;;
esac
