#!/usr/bin/env bash

set -e
# set -x

git_ci_command="$1" && shift
testset="$1"        && shift

ci_ref_prefix="refs/ci/$testset"

clean_worktree_or_die() {
    if ! git diff --quiet; then
        echo "Must run with a clean worktree!!!"
        exit 1
    fi
}

git_ci_config() {
    git config --file='.ci' "$@"
}

git_ci_tracked_files() {
    git_ci_config --get "test.$testset.trackedFiles"
}

git_ci_add() {
    git add --force $(git_ci_tracked_files)
}

git_ci_commit() {
    local source_commit source_tree ci_ref
    local tested_commit tested_tree tested_commit_parent

    source_commit="$(git rev-parse HEAD)"
    source_tree="$(git rev-parse "$source_commit^{tree}")"
    ci_ref="$ci_ref_prefix/$source_tree"

    tested_tree="$(git write-tree)"

    tested_commit_parent="$(git rev-parse --verify --quiet "$ci_ref")" \
        || tested_commit_parent="$(git commit-tree "$source_tree" -m "ci: init '$testset' on tree '$source_tree'")"
    tested_commit="$(git commit-tree -p "$tested_commit_parent" "$tested_tree" -m "ci: run '$testset' on commit '$source_commit'")"

    git update-ref "$ci_ref" "$tested_commit"
}

git_ci_get_test_results() {
    local source_commit source_tree
    source_commit="$1" && shift
    source_tree="$(git rev-parse "$source_commit^{tree}")"
    git rev-parse --verify --quiet "$ci_ref_prefix/$source_tree" \
        || { echo "No test results for '$source_commit'." >&2
             exit 1
           }
}

git_ci_show() {
    local source_commit_one source_commit_two
    local tested_commit_one tested_commit_two
    local max_backtrack

    max_backtrack='10'

    { source_commit_one="$1" && shift ; } || source_commit_one="HEAD"
    { source_commit_two="$1" && shift ; } || source_commit_two="$source_commit_one^"

    tested_commit_one="$(git_ci_get_test_results "$source_commit_one")"

    for i in $(seq 0 $max_backtrack); do
        tested_commit_two="$(git_ci_get_test_results "$source_commit_two^$i" 2>/dev/null)" || true
        if [[ "$tested_commit_two" != '' ]]; then
            echo "index $source_commit_two^$i..$source_commit_one"
            git diff "$tested_commit_two" "$tested_commit_one"
            return
        fi
    done

    echo "No test results found for '$source_commit_two^$max_backtrack..$source_commit_two'." >&2
    exit 1
}

git_ci_cleanup() {
    git reset
    git checkout -- ./
    git clean -dfx
}

git_ci_test() {
    local test_command

    clean_worktree_or_die

    test_command="$(git_ci_config --get "test.$testset.command")"
    echo "== git ci: running test '$test_command'"
    exit_status="0"

    git ci cleanup "$testset"
    bash -c "$test_command" || exit_status="$?"
    git ci add     "$testset"
    git ci commit  "$testset"
    git ci cleanup "$testset"

    return "$exit_status"
}

git_ci_run() {
    [[ "$#" != '0' ]] || set 'HEAD' '^HEAD^'

    clean_worktree_or_die

    for commit_id in $(git rev-list "$@"); do
        git checkout "$commit_id"
        git ci test "$testset" || true
    done
}

# git_ci_init() {
#     local init_ci="$1" && shift
#     git branch --force "$ci_ref_prefix" "$init_ci"
# }
#
# git_ci_reinit() {
#     local last_common="$(git merge-base "$branch" "$ci_ref_prefix")"
#     local next_ci_branch="$ci_ref_prefix"
#     while [[ "$(git merge-base "$branch" "$next_ci_branch^")" == "$last_common" ]]; do
#         next_ci_branch="$next_ci_branch^"
#     done
#     git ci init "$branch" "$testset" "$(git rev-parse $next_ci_branch)"
# }

git_ci_start() {
    local rebase_root
    rebase_root="$1" && shift
    git rebase --interactive --exec "git ci run $testset || true" "$rebase_root"
}

echo "== git ci: $git_ci_command $testset $@"
case "$git_ci_command" in
    cleanup) git_ci_cleanup    ;;
    test)    git_ci_test       ;;
    add)     git_ci_add        ;;
    commit)  git_ci_commit     ;;
    run)     git_ci_run   "$@" ;;
    show)    git_ci_show  "$@" ;;
    start)   git_ci_start "$@" ;;
    *)       echo "Unrecognized git ci command: $git_ci_command..." && exit 1 ;;
esac
