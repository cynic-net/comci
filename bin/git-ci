#!/usr/bin/env bash

set -e
# set -x

git_ci_command="$1" && shift
testset="$1"        && shift

ci_config=".ci"
ci_ref_prefix="refs/ci/$testset"

# Utilities
# ---------

notif() { echo "== git ci ($testset): $@" >&2 ; }
fatal() { notif "$@" ; exit 1                 ; }

clean_worktree_or_die() {
    git submodule update --init
    if ! git diff --quiet; then
        fatal "Must run with a clean worktree!!!"
    fi
}

commit_comes_before_or_die() {
    local source_commit_one source_commit_two
    local mbase

    source_commit_one="$1" && shift
    source_commit_two="$1" && shift

    { mbase="$(git merge-base "$source_commit_one" "$source_commit_two")" \
        && [[ "$mbase" == "$(git rev-parse "$source_commit_one")" ]]
    } || fatal "Commit order does not hold: $source_commit_one <= $source_commit_two"
}

commit_exists() {
    local source_commit

    source_commit="$1" && shift
    git rev-parse --verify --quiet "$source_commit" &>/dev/null
}

# Configuration
# -------------

git_ci_config() {
    git config --file="$ci_config" "$@"
}

git_ci_tracked_files() {
    git_ci_config --get "test.$testset.trackedFiles" \
        || fatal "Entry not found: test.$testset.trackedFiles"
}

# Storing Results
# ---------------

git_ci_add() {
    for file in $(git_ci_tracked_files); do
        [[ ! -f "$file" ]] || git add --force "$file"
        [[ ! -d "$file" ]] || git add --force "$file"
    done
}

git_ci_commit() {
    local source_commit source_tree ci_ref
    local tested_commit tested_tree tested_commit_parent

    source_commit="$(git rev-parse HEAD)"
    source_tree="$(git rev-parse "$source_commit^{tree}")"
    ci_ref="$ci_ref_prefix/$source_tree"

    tested_tree="$(git write-tree)"

    tested_commit_parent="$(git rev-parse --verify --quiet "$ci_ref")" \
        || tested_commit_parent="$(git commit-tree "$source_tree" -m "ci: init '$testset' on tree '$source_tree'")"
    tested_commit="$(git commit-tree -p "$tested_commit_parent" "$tested_tree" -m "ci: run '$testset' on commit '$source_commit'")"

    git update-ref "$ci_ref" "$tested_commit"
}

# Reading Results
# ---------------

set_source_commit() {
    local shift_count

    shift_count='0'
    { source_commit="$1" \
        && commit_exists "$source_commit" \
        && shift_count='1'
    } || source_commit='HEAD'

    return "$shift_count"
}

git_ci_get() {
    local source_commit source_tree ci_ref
    set_source_commit "$@" || shift "$?"

    source_tree="$(git rev-parse "$source_commit^{tree}")"
    ci_ref="$ci_ref_prefix/$source_tree"
    commit_exists "$ci_ref" || return
    echo "$ci_ref"
}

git_ci_diff() {
    local source_commit_one source_commit_two
    local tested_commit_one tested_commit_two

    source_commit_one="$1" && shift
    source_commit_two="$1" && shift

    tested_commit_two="$(git_ci_get "$source_commit_two")"
    if [[ "$source_commit_one" == '' ]]; then
        tested_commit_one="$source_commit_two"
    else
        tested_commit_one="$(git_ci_get "$source_commit_one")"
    fi

    git diff "$tested_commit_one" "$tested_commit_two" "$@"
}

git_ci_last() {
    local source_commit curr_commit max_backtrack
    max_backtrack=50
    set_source_commit "$@" || shift "$?"

    for i in $(seq 0 "$max_backtrack"); do
        curr_commit="$source_commit~$i"
        commit_exists "$curr_commit" \
            || { notif "Not a commit: '$curr_commit'"
                 break
               }
        if git_ci_get "$curr_commit" &>/dev/null; then
            echo "$curr_commit"
            return 0
        fi
    done

    notif "No test results found between: $curr_commit..$source_commit"
}

git_ci_list() {
    local source_commit
    set_source_commit "$@" || shift "$?"

    source_commit="$(git_ci_last "$source_commit" 2>/dev/null)"
    while [[ "$source_commit" != '' ]]; do
        echo "$(git rev-parse "$source_commit")"
        source_commit="$(git_ci_last "$source_commit^" 2>/dev/null)"
    done
}

git_ci_listdiff() {
    local source_commit source_commit_one source_commit_two last_commit
    set_source_commit "$@" || shift "$?"
    source_commit_one="$(git rev-parse "$source_commit")"
    last_commit=''

    echo "$source_commit_one"
    while read source_commit_two; do
        if ! git_ci_diff "$source_commit_two" "$source_commit_one" --quiet -- $(git_ci_tracked_files); then
            echo "$source_commit_two"
            source_commit_one="$source_commit_two"
        fi
        [[ "$source_commit_two" == '' ]] || last_commit="$source_commit_two"
    done < <(git_ci_list "$source_commit_one")
    [[ "$last_commit" == '' ]] || echo "$last_commit"
}

# Removing Results
# ----------------

git_ci_clear() {
    local source_commit source_tree ci_ref
    set_source_commit "$@" || shift "$?"

    ci_ref="$(git_ci_get "$source_commit")" \
        || { notif "No test results for: $source_commit"
             return 1
           }
    notif "Clearing test results for: $source_commit"
    git update-ref -d "$ci_ref"
}

git_ci_clear_all() {
    local source_commit curr_commit
    set_source_commit "$@" || shift "$?"

    for curr_commit in $(git_ci_list "$source_commit"); do
        git_ci_clear "$curr_commit" || true
    done
}

# Presenting Results
# ------------------

git_ci_show() {
    local source_commit_one source_commit_two source_commit
    local tested_commit_one tested_commit_two

    set_source_commit "$@" || shift "$?"
    source_commit_one="$source_commit"
    source_commit_two="$(git_ci_last "$source_commit_one^")"

    git_ci_diff "$source_commit_two" "$source_commit_one" "$@"
}

# Generate a history for use with git-log or git-show. Outputs the commit id
# of the HEAD, but does not create a ref.

git_ci_gen_hist() {
    local source_commit source_ancestor source_message
    local tested_ancestor tested_ancestor_tree
    local generated_commit
    set_source_commit "$@" || shift "$?"

    while read source_ancestor; do
        local parent_args=()
        [[ "$generated_commit" == "" ]] ||
            parent_args+=( '-p' "$generated_commit" )
        parent_args+=( '-p' "$source_ancestor" )

        tested_ancestor="$(git_ci_get "$source_ancestor")"
        tested_ancestor_tree="$(git rev-parse "$tested_ancestor^{tree}")"

        source_message="$(git log -n1 --format=%s "$source_ancestor")"
        generated_commit="$(git commit-tree "${parent_args[@]}" \
            "$tested_ancestor_tree" -m "ci: $testset: $source_message")"
    done < <(git_ci_list "$source_commit" | tac)
    echo "$generated_commit"
}

git_ci_hist() {
    local source_commit
    set_source_commit "$@" || shift "$?"

    git log --abbrev-commit --decorate --date=relative --graph --topo-order \
            --format=format:'%C(bold green)%h%C(reset) - %C(dim blue)%s%C(reset) - %C(blue)%an%C(reset)%C(bold yellow)%d%C(reset)' \
            "$(git_ci_gen_hist "$source_commit")" "$@"
}

# Running Tests
# -------------

git_ci_cleanup() {
    git reset
    git checkout -- ./
}

git_ci_test() {
    local test_command

    test_command="$(git_ci_config --get "test.$testset.command")"
    bash -c "$test_command"
}

git_ci_run() {
    local source_commit curhead exit_status
    set_source_commit "$@" || shift "$?"
    clean_worktree_or_die
    exit_status='0'

    # TODO: record exit codes and report back correct exit code?
    # Perhaps with trailers in commit message? (git interpret-trailers)
    # Otherwise, `git ci run-bisect/sparse` may act strange.
    if git_ci_get "$source_commit" &>/dev/null; then
        notif "Test results already exist for: $source_commit"
    else
        notif "Running tests on commit: $source_commit"

        curhead="$(git rev-parse --abbrev-ref HEAD)"
        trap "git checkout $curhead ; exit 1" INT TERM EXIT

        git checkout "$source_commit"

        git_ci_cleanup
        git_ci_test     || exit_status="$?"
        git_ci_add
        git_ci_commit
        git_ci_cleanup

        git checkout "$curhead"
    fi

    if [[ "$#" != '0' ]]; then
        git_ci_run "$@" || exit_status="$?"
    fi

    return "$exit_status"
}

# Over Spans of Commits
# ---------------------

# $source_commit_one^..$source_commit_two
set_source_commit_one_two() {
    local shift_count='0'

    { source_commit_one="$1" \
        && commit_exists "$source_commit_one" \
        && shift \
        && shift_count='1'
    } || source_commit_one="$(git_ci_last)"
    [[ "$source_commit_one" != '' ]] \
        || fatal "No starting commit supplied and no last tested commit found."

    { source_commit_two="$1" \
        && commit_exists "$source_commit_two" \
        && shift \
        && shift_count='2'
    } || source_commit_two="HEAD"
    commit_comes_before_or_die "$source_commit_one" "$source_commit_two"

    return "$shift_count"
}

git_ci_run_linear() {
    local curhead
    local source_commit_one source_commit_two

    set_source_commit_one_two "$@" || shift "$?"

    git_ci_run $(git rev-list "$source_commit_one^..$source_commit_two")
}

git_ci_run_bisect() {
    local source_commit_one source_commit_two
    local mid_rev exit_status

    set_source_commit_one_two "$@" || shift "$?"

    exit_status='0'

    git_ci_run "$source_commit_one" "$source_commit_two" || exit_status="$?"

    if ! git_ci_diff "$source_commit_one" "$source_commit_two" --quiet -- $(git_ci_tracked_files); then
        mid_rev="$(git rev-list --bisect "$source_commit_one..$source_commit_two")"
        [[ "$mid_rev" != '' ]] \
            && [[ "$mid_rev" != "$source_commit_one" ]] \
            && [[ "$mid_rev" != "$source_commit_two" ]] \
            || return "$exit_status"
        git_ci_run_bisect "$source_commit_one" "$mid_rev" || exit_status="$?"
        git_ci_run_bisect "$mid_rev" "$source_commit_two" || exit_status="$?"
    fi

    return "$exit_status"
}

git_ci_run_sparse() {
    local source_commit_one source_commit_two
    local bisect_commit_one bisect_commit_two
    local exit_status

    set_source_commit_one_two "$@" || shift "$?"

    exit_status='0'

    git_ci_run "$source_commit_one" "$source_commit_two" || exit_status="$?"

    bisect_commit_two="$source_commit_two"
    for bisect_commit_one in $(git_ci_list "$source_commit_two^"); do
        git_ci_run_bisect "$bisect_commit_one" "$bisect_commit_two" || exit_status="$?"
        bisect_commit_two="$bisect_commit_one"
        [[ "$(git rev-parse "$bisect_commit_one")" != "$(git rev-parse "$source_commit_one")" ]] || break
    done

    return "$exit_status"
}

# Main
# ----

git_ci_config --get-regexp "test.$testset" &>/dev/null \
    || fatal "Entry not found in '$ci_config': test.$testset"

notif "$git_ci_command $testset $@"
case "$git_ci_command" in
    cleanup)    git_ci_cleanup         ;;
    test)       git_ci_test            ;;
    add)        git_ci_add             ;;
    commit)     git_ci_commit          ;;
    get)        git_ci_get        "$@" ;;
    run)        git_ci_run        "$@" ;;
    run-linear) git_ci_run_linear "$@" ;;
    run-bisect) git_ci_run_bisect "$@" ;;
    run-sparse) git_ci_run_sparse "$@" ;;
    diff)       git_ci_diff       "$@" ;;
    show)       git_ci_show       "$@" ;;
    last)       git_ci_last       "$@" ;;
    gen-hist)   git_ci_gen_hist   "$@" ;;
    list)       git_ci_list       "$@" ;;
    listdiff)   git_ci_listdiff   "$@" ;;
    clear)      git_ci_clear      "$@" ;;
    clear-all)  git_ci_clear_all  "$@" ;;
    hist)       git_ci_hist       "$@" ;;
    hists)      git_ci_hist -m --first-parent --stat  "$@" ;;
    histp)      git_ci_hist -m --first-parent --patch "$@" ;;
    *)          expanded_alias=($(git config --get "alias.$git_ci_command")) \
                   || fatal "Unrecognized command: $git_ci_command"
                eval git ci "${expanded_alias[0]}" "$testset" "${expanded_alias[@]:1}" "$@"
                ;;
esac
