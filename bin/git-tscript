#!/usr/bin/env python3

from    argparse  import ArgumentParser
from    os  import chdir, getcwd
from    pathlib  import Path
from    stat  import S_IXUSR
from    subprocess  import run
from    sys  import stderr

from    pygit2  import *


####################################################################
#   Main

ARGS = None     # set by parseargs()

def main():
    ARGS = parseargs()
    repo = find_repo()
    project_root = Path(repo.path).parent
    chdir(project_root)
    for ts in tscripts(project_root):
        #   XXX in both cases here we should be dealing with the optional
        #   single argument to the test(s) somehow?
        if ARGS.interactive:
            run_ts_interactive(ts)
        else:
            run_ts_capture(foreground=ARGS.foreground)

def parseargs():
    p = ArgumentParser(description='''
        Summary of what this program does.
        And details on further lines.''',
        epilog='Text after options are listed')
    p.add_argument('-i', '--interactive', action='store_true')
    p.add_argument('-f', '--foreground', action='store_true')
    return p.parse_args()

####################################################################
#   Run process functions

def run_ts_interactive(arg=None):
    run_ts(arg)

def run_ts_capture(foreground):
    #   This should set up the output to be captured into the repo
    #   (or files if working copy is modified) and then run the
    #   test in the background, not waiting for completion.
    raise NotImplementedError('XXX write me')

def run_ts(ts, arg=None, io=(None, None, None, None)):
    if arg is None:
        command = [ts]
        fprint('━━━━━━━━━━━━ {}'.format(ts.name))
    else:
        command = [ts, arg]
        fprint('━━━━━━━━━━━━ {} {}'.format(ts.name, arg))

    ec = run(command).returncode
    if ec != 0:
        die(ec, 'FAILED (exitcode={})'.format(ec))

####################################################################
#   File system functions

def find_repo():
    cwd = getcwd()
    debug('cwd:', cwd)
    repo_path = discover_repository(cwd)
    debug('repo_path:', repo_path)
    repo = Repository(repo_path)
    debug('repo:', repo)
    return repo

def tscripts(project_root):
    for pts in sorted(project_root.glob('tscript/*')):
        is_exec = pts.stat().st_mode & S_IXUSR
        if not pts.is_file() or not is_exec: continue
        yield pts

####################################################################
#   Print and fail functions

def debug(*s):
    return
    print(*s, file=stderr, flush=True)

def fprint(*args):
    print(*args, flush=True)

def die(exitcode, *s):
    print(*s, file=stderr, flush=True)
    print( 'XXX exitcode:', exitcode, file=stderr, flush=True)
    exit(exitcode)

####################################################################

if __name__ == '__main__': main()
