#!/usr/bin/env python3

from    argparse  import ArgumentParser
from    os  import chdir, getcwd
from    pathlib  import Path
from    stat  import S_IXUSR
from    subprocess  import run, DEVNULL
from    sys  import stdout, stderr

from    pygit2  import *


####################################################################
#   Main

ARGS = None     # set by parseargs()

def main():
    ARGS = parseargs()
    repo = find_repo()
    project_root = Path(repo.path).parent
    chdir(project_root)
    for ts in tscripts(project_root):
        #   XXX in both cases here we should be dealing with the optional
        #   single argument to the test(s) somehow?
        if ARGS.interactive:
            run_ts_interactive(ts, arg=None)
        else:
            run_ts_capture(ts, arg=None, foreground=ARGS.foreground)

def parseargs():
    p = ArgumentParser(description='''
        Summary of what this program does.
        And details on further lines.''',
        epilog='Text after options are listed')
    p.add_argument('-i', '--interactive', action='store_true')
    p.add_argument('-f', '--foreground', action='store_true')
    return p.parse_args()

####################################################################
#   Run single tests.

def run_ts_interactive(ts, arg=None):
    ''' Run a single test script in "interactive" mode, with the
        stdin/stdout/stderr of this process, wait for the child process to
        exit, and return if the test was successful (child exited with
        zero) or exit this program with the same exit code the child
        returned.
    '''
    ec = run_ts(ts, arg)
    if ec != 0: exit(ec)

def run_ts_capture(ts, arg=None, foreground=False):
    ''' XXX capture output

        ``stdin`` is always ``/dev/null``.
    '''
    #   This should set up the output to be captured into the repo
    #   (or files if working copy is modified) and then run the
    #   test in the background, not waiting for completion.
    #   XXX 2. implement capture to file: `.build/tscript.out/TS.ARG.out`
    #   XXX 3. implement background running
    #   XXX 4. implement capture to repo commit

    ec = run_ts(ts, arg, io=(DEVNULL, None, None))
    fprint(stdout, 'git-tscript: {}{} completed (exit={})'.format(
        ts.name, ' ' + arg if arg else '', ec))

def run_ts(ts, arg=None, io=(None, None, None)):
    ''' Log a test header to `io[1]` (`stdout` if it's `None`) and run
        the program at path `ts`. `io` is a tuple of file descriptors for
        ``(stdin, stdout, stderr)``; `None` values indicate to inherit the
        file descriptor from this process.

        This logs a 'FAILED message if the child process returns any
        exit code other than 0. It returns the exit code of the child
        process.
    '''
    header_fd = io[1];
    if header_fd is None: header_fd = stdout
    if arg is None:
        command = [ts]
        fprint(header_fd, '━━━━━━━━━━━━ {}'.format(ts.name))
    else:
        command = [ts, arg]
        fprint(header_fd, '━━━━━━━━━━━━ {} {}'.format(ts.name, arg))

    debug('io:', io)
    ec = run(command, stdin=io[0], stdout=io[1], stderr=io[2]).returncode
    if ec != 0: fprint(header_fd, '━━━━━ FAILED (exitcode={})'.format(ec))
    return ec

####################################################################
#   File system functions

def find_repo():
    cwd = getcwd()
    debug('cwd:', cwd)
    repo_path = discover_repository(cwd)
    debug('repo_path:', repo_path)
    repo = Repository(repo_path)
    debug('repo:', repo)
    return repo

def tscripts(project_root):
    for pts in sorted(project_root.glob('tscript/*')):
        is_exec = pts.stat().st_mode & S_IXUSR
        if not pts.is_file() or not is_exec: continue
        yield pts

####################################################################
#   Print and fail functions

def debug(*s):
    return
    print(*s, file=stderr, flush=True)

def fprint(fd, *args):
    print(*args, file=fd, flush=True)

def die(exitcode, *s):
    print(*s, file=stderr, flush=True)
    print( 'XXX exitcode:', exitcode, file=stderr, flush=True)
    exit(exitcode)

####################################################################

if __name__ == '__main__': main()
