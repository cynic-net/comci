comci: Committed Continuous Integration Results
===============================================

Comci (pronounced /COM si/ or /com SI/) is a system for running unit and
integration tests for a Git commit and storing the results of those tests
in the Git repo, associated with the Git commit against which they were
run.

This is an aid to [_continuous integration,_][ci] a concept from [Extreme
Programming][xp] where the entire system as currently under development is
tested very frequently: at least once per day but preferably more often.
These tests may be started manually (by simply running `git tscript`
frequently) or assissted by a system that runs the tests automatically,
without explicit requests by the developer.

### Structure

`git tscript` runs ___tests___ that are exectuable files directly under the
`tscript/` directory under the project root. (These must be at the top
level of `tscript/`; subdirectories are not searched.)

Each test may have an optional ___parameter___ that's an arbitrary string
passed to the test to change its behaviour in some way. E.g.,
`test_sed_script` might take a parameter of `linux`, `BSD` or `MacOS` to
test a sed script using that OS's version of `sed`.

The default parameters (if any) used for tests come from `.param-list` and
`.param-gen` files with the same prefix as the test name. So given the
following `tscript/` directory, with user file modes shown as a prefix:

    rwx  tscript/A              # executable file, so is a test program
    rw-  tscript/A.data         # not executable file; ignored
    rwx  tscript/B              # test program
    rw-  tscript/B.param-list
    rwx  tscript/B.param-gen    # must be executable
    rwx  tscript/C/             # not executable file; ignored

we have two tests:
- `A`, which is run without a parameter by default. (It may still be given
  a parameter if provided by the user at the command line, though the test
  may ignore it.)
- `B`, which is by default run multiple times, once with each default
  parameter. The list of default parameters is generated by reading the
  contents of `B.param-list`, running the `B.param-gen` program, and
  combining the two. (These do not both have to be present.)

The `.param-list` file and `.param-gen` output have the same format:
- Empty lines (but not lines containing whitespace) are ignored.
- Comment lines starting with `#` (no leading whitespace is allowed)
- Other lines are a single parameter, used exactly as-is (no whitespace
  stripping or other processing is done).

If tests are specified on the `git tscript` command line, they are
specified using a ___test-spec___ of a test name followed by an optional
comma and test parameter, e.g., `A`, `A,alternate`, `B,first`. Note that
specifying just `B` using the configuration above will run `B` with each of
the default parameters in turn: if default parameters are supplied for a
test there is no way to run it without a parameter.

XXX update `comci-tests/10-repo-files/` to include default parameters per
example above.

### XXX

    tscript run [-f] COMMIT TEST-SPEC ...                   # cap-commit, background
    tscript run [-f] .      TEST-SPEC ...                   # cap-files,  background
    tscript run   -i COMMIT TEST-SPEC ... -- test-args      # cap-none,   foreground
    tscript run   -i .      TEST-SPEC ... -- test-args      # cap-none,   foreground
    tscript show ...
    tscript list ... # ?

Consider later making `COMMIT` optional, defaulting to HEAD.

Though we say COMMIT above, results are stored indexed by the tree to which
that commit points. Two different commits with the same tree will have the
same results.

### Usage Overview

The unit and integration tests for a system are divided up into a set of
test scripts, or _tscripts;_ each tscript may optionally take a single
parameter. Comci adds a `tscript` sub-command to Git to manage running the
tests, viewing and transfering the results, and the like. A typical
session might be:

    $ git commit -m 'my new changes'

    #   Run three test scripts from the full set: 'unit' and 'brief' with
    #   no parameters passed to them, and 'int' with the parameter 'foo'
    #   and 'bar'. These will be run in the background on new working
    #   copies from that commit (a separate working copy for each test) and
    #   the user will be informed as each one completes.

    $ git tscript run @ unit brief int,foo int,bar

    #   Here the user can do other things while waiting for the tests to
    #   complete. For example, run tests against the the _current_ working
    #   copy (`-i`/`--interactive` option) instead of a commit. This will
    #   be run in the foreground and the results will not be recorded to git.

    $ vi foo.py
    $ git tscript run -i . unit

    $ git commit -m 'FIXUP: Clean up blah blah blah'

    #   After completion the results can be examined:

    $ git log -2            # A Git note will summarise the results
    $ git tscript show @^   # Shows details of the tests we ran at the
                            # start against the parent of our fixup commit.

    #   If all is happy, you can generate a new commit with your cleanup
    #   and the full set of tests for it. This will run all test scripts
    #   under tscript/, including 'int' several times with each parameter
    #   from a list of all the parameters in tscript/int.params.

    $ git rebase -i         # Squash fixups into final commit.
    $ git tscript run @     # Run all tests against this new commit. If the
                            # commit has already had some tests run against
                            # it, this will run only the not-yet-run tests.
                            # Since test results are linked to the commit's
                            # tree, squashing commits will not force
                            # re-running tests.

    #   You can work on something else while these run in the background.

    $ git push                      # Make code available for review.
    $ git checkout dev/cjs/other    # Hack on different code.
    ...
    $ git checkout -                # When tests are complete.
    $ git push                      # Make test results available for review.



<!-------------------------------------------------------------------->
[ci]: https://en.wikipedia.org/wiki/Continuous_integration
[xp]: https://en.wikipedia.org/wiki/Extreme_programming
